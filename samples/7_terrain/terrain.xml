<?xml version='1.0'?>

<effect>
  <shader type="vertex_shader" name="TerrainVS">
    <attrib  name="pos" usage="position"/>
    <attrib  name="tex_coord" usage="texture_coord"/>
    <uniform type="mat4" name="mvp"/>
    <uniform type="vec3" name="center"/>
    <uniform type="vec3" name="extent"/>
    <uniform type="sampler" name="height_tex">
      <state name="filtering" value="min_mag_mip_linear"/>
      <state name="address_u" value="clamp"/>
      <state name="address_v" value="clamp"/>
    </uniform>
    <code>
      <![CDATA[
in vec3 pos;
in vec2 tex_coord;

uniform mat4 mvp;
uniform vec3 center;
uniform vec3 extent;

uniform sampler2D height_tex;

void main()
{
  
}
      ]]>
    </code>
  </shader>

  <shader type="fragment_shader" name="TerrainFS">
    <!--<uniform type="sampler" name="normal_tex">
      <state name="filtering" value="min_mag_linear_mip_nearest"/>
      <state name="address_u" value="clamp"/>
      <state name="address_v" value="clamp"/>
    </uniform>-->
    <uniform type="sampler" name="grass_tex">
      <state name="filtering" value="min_mag_mip_linear"/>
      <state name="address_u" value="wrap"/>
      <state name="address_v" value="wrap"/>
    </uniform>
    <!--<uniform type="float" name="inv_far"/>-->
    <code>
      <![CDATA[
in vec4 pass_texCoord;
in vec3 pass_normal;

uniform sampler2D grass_tex;
uniform float inv_far;

const vec3 LightDir = vec3(0, 10, 5);

out vec4 out_color;

void main()
{

  vec3 normal = normalize(pass_normal);
  out_color = vec4(texture(grass_tex, pass_texCoord.zw).rgb * 
    dot(normalize(LightDir), normal) * 0.0001 + normal, 1.0f);
}
      ]]>
    </code>
  </shader>


  <shader type="vertex_shader" name="HeightToNormalVS">
    <attrib  name="pos" usage="position"/>
    <attrib  name="uv" usage="texture_coord"/>
    <uniform type="vec2" name="dimension"/>
    <uniform type="mat4" name="mvp"/>
    <uniform type="vec3" name="pos_center"/>
    <uniform type="vec3" name="pos_extent"/>
    <code>
      <![CDATA[
in vec3 pos;
in vec2 uv;

uniform vec2 dimension;
uniform mat4 mvp;
uniform vec3 pos_center;
uniform vec3 pos_extent;

out vec2 pass_step;
out vec2 pass_uv;

void main()
{
  gl_Position = mvp * vec4((pos + pos_center) * pos_extent, 1.0f);
  pass_step = vec2(-1.0f / dimension.x, -1.0f / dimension.y);
  pass_uv = uv;
}
      ]]>
    </code>
  </shader>
  
  <shader type="fragment_shader" name="HeightToNormalFS">
    <uniform type="float" name="dz"/>
    <uniform type="sampler" name="height_tex">
      <state name="filtering" value="min_mag_mip_linear"/>
      <state name="address_u" value="wrap"/>
      <state name="address_v" value="wrap"/>
    </uniform>
    <code>
      <![CDATA[
in vec2 pass_step;
in vec2 pass_uv;

uniform float dz;

uniform sampler2D height_tex;

void main()
{
  const vec2 step = pass_step, uv = pass_uv;
  
	vec2 tlv = vec2(uv.x - step.x, uv.y + step.y );
	vec2 lv  = vec2(uv.x - step.x, uv.y 		     );
	vec2 blv = vec2(uv.x - step.x, uv.y - step.y );	
	vec2 tv  = vec2(uv.x,          uv.y + step.y ); 
	vec2 bv  = vec2(uv.x,          uv.y - step.y );
	vec2 trv = vec2(uv.x + step.x, uv.y + step.y ); 
	vec2 rv  = vec2(uv.x + step.x, uv.y 		     );
	vec2 brv = vec2(uv.x + step.x, uv.y - step.y );
  
	tlv = vec2(tlv.x >= 0.0 ? tlv.x : (1.0 + tlv.x), 	tlv.y >= 0.0	? tlv.y : (1.0  + tlv.y));
	tlv = vec2(tlv.x < 1.0  ? tlv.x : (tlv.x - 1.0 ), tlv.y < 1.0   ? tlv.y : (tlv.y - 1.0 ));
	lv  = vec2( lv.x >= 0.0 ?  lv.x : (1.0 + lv.x),  	 lv.y >= 0.0 	?  lv.y : (1.0  +  lv.y));
	lv  = vec2( lv.x < 1.0  ?  lv.x : ( lv.x - 1.0 ),  lv.y < 1.0  	?  lv.y : ( lv.y - 1.0 ));
	blv = vec2(blv.x >= 0.0 ? blv.x : (1.0 + blv.x), 	blv.y >= 0.0 	? blv.y : (1.0  + blv.y));
	blv = vec2(blv.x < 1.0  ? blv.x : (blv.x - 1.0 ), blv.y < 1.0 	? blv.y : (blv.y - 1.0 ));
	tv  = vec2( tv.x >= 0.0 ?  tv.x : (1.0 + tv.x),  	 tv.y >= 0.0 	?  tv.y : (1.0  +  tv.y));
	tv  = vec2( tv.x < 1.0  ?  tv.x : ( tv.x - 1.0 ),  tv.y < 1.0 	?  tv.y : ( tv.y - 1.0 ));
	bv  = vec2( bv.x >= 0.0 ?  bv.x : (1.0 + bv.x),  	 bv.y >= 0.0 	?  bv.y : (1.0  +  bv.y));
	bv  = vec2( bv.x < 1.0  ?  bv.x : ( bv.x - 1.0 ),  bv.y < 1.0 	?  bv.y : ( bv.y - 1.0 ));
	trv = vec2(trv.x >= 0.0 ? trv.x : (1.0 + trv.x), 	trv.y >= 0.0 	? trv.y : (1.0  + trv.y));
	trv = vec2(trv.x < 1.0  ? trv.x : (trv.x - 1.0 ), trv.y < 1.0   ? trv.y : (trv.y - 1.0 ));
	rv  = vec2( rv.x >= 0.0 ?  rv.x : (1.0 + rv.x),  	 rv.y >= 0.0 	?  rv.y : (1.0  +  rv.y));
	rv  = vec2( rv.x < 1.0  ?  rv.x : ( rv.x - 1.0 ),  rv.y < 1.0   ?  rv.y : ( rv.y - 1.0 ));
	brv = vec2(brv.x >= 0.0 ? brv.x : (1.0 + brv.x), 	brv.y >= 0.0 	? brv.y : (1.0  + brv.y));
	brv = vec2(brv.x < 1.0  ? brv.x : (brv.x - 1.0 ), brv.y < 1.0   ? brv.y : (brv.y - 1.0 ));
  
  float tl = textureLod(height_tex, tlv, 0).r;
	float l  = textureLod(height_tex, lv , 0).r;
	float bl = textureLod(height_tex, blv, 0).r;
	float t  = textureLod(height_tex, tv , 0).r;
	float b  = textureLod(height_tex, bv , 0).r;
	float tr = textureLod(height_tex, trv, 0).r;
	float r  = textureLod(height_tex, rv , 0).r;
	float br = textureLod(height_tex, brv, 0).r;
  
	float dx = tl + l*2.0 + bl - tr - r*2.0 - br;
	float dy = tl + t*2.0 + tr - bl - b*2.0 - br;
  
  vec4 normal = vec4(normalize(vec3(dx * 255.0, dy * 255.0, dz)), textureLod(height_tex, uv, 0).a);
  gl_FragColor = vec4(normal.xy * 0.5 + 0.5, normal.zw);
}
      ]]>
    </code>
  </shader>

  <!--<technique name="Terrain">
    <state name="vertex_shader" value="TerrainVS"/>
      <state name="fragment_shader" value="TerrainFS"/>
  </technique>-->

  <technique name="HeightToNormalTech">
    <state name="cull_mode" value="none"/>
    <state name="vertex_shader" value="HeightToNormalVS"/>
    <state name="fragment_shader" value="HeightToNormalFS"/>
  </technique>
  
</effect>